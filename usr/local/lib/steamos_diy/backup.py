#!/usr/bin/env python3
# =============================================================================
# PROJECT:      SteamMachine-DIY - Backup Tool
# VERSION:      1.1.0 - Python
# DESCRIPTION:  Surgical backup with dynamic symlink recovery and user configs.
# PHILOSOPHY:   KISS (Keep It Simple, Stupid)
# REPOSITORY:   https://github.com/dlucca1986/SteamMachine-DIY
# PATH:         /usr/local/lib/steamos_diy/backup_tool.py
# LICENSE:      MIT
# =============================================================================

import os
import pwd
import subprocess
import sys
import tarfile
from datetime import datetime
from pathlib import Path


def get_ssot():
    """
    Loads SSoT (Single Source of Truth) configuration.
    Determines paths dynamically based on environment and active session.
    """
    conf = {
        "next_session": "/var/lib/steamos_diy/next_session",
    }

    # Detect actual user. If root (pkexec/sudo), look for the session owner.
    user = os.environ.get("SUDO_USER")
    if not user or user == "root":
        try:
            # Get the owner of the current seat/session
            cmd = "loginctl user-status | head -n 1 | awk '{print $1}'"
            user = subprocess.check_output(cmd, shell=True, text=True).strip()
        except Exception:
            user = os.environ.get("USER")

    conf["user"] = user

    # Load system-wide overrides
    path = "/etc/default/steamos_diy.conf"
    if os.path.exists(path):
        with open(path, "r") as f:
            for line in f:
                if "=" in line and not line.startswith("#"):
                    k, v = line.split("=", 1)
                    conf[k.strip()] = v.strip().strip('"').strip("'")

    # Set Home directory path based on detected user
    if user and user != "root":
        conf["user_home"] = f"/home/{user}"
    else:
        conf["user_home"] = "/root"

    return conf


def generate_links_recap():
    """
    Scans for symbolic links pointing to the project core directory.
    Generates a shell script to restore them on a new installation.
    """
    target_prefix = "/usr/local/lib/steamos_diy"
    recap_commands = [
        "#!/bin/bash\n",
        "# Automatic symlink recovery script generated by SteamMachine-DIY\n",
        "echo 'Restoring project symbolic links...'\n",
    ]

    try:
        # Search for links pointing to the source directory
        cmd = ["find", "/usr", "-type", "l", "-lname", f"{target_prefix}*"]
        links = subprocess.check_output(
            cmd, text=True, stderr=subprocess.DEVNULL
        ).splitlines()

        if not links:
            recap_commands.append("# No symbolic links were detected.\n")
        else:
            for link_path in links:
                target = os.readlink(link_path)
                parent_dir = os.path.dirname(link_path)
                recap_commands.append(f"mkdir -p {parent_dir}\n")
                recap_commands.append(f"ln -sf {target} {link_path}\n")
    except Exception as e:
        recap_commands.append(f"# Error during link scan: {e}\n")

    return "".join(recap_commands)


def run_backup():
    """
    Performs the backup procedure:
    1. Generates restoration script for symlinks.
    2. Packages system configs, SSoT, and source files into an archive.
    """
    ssot = get_ssot()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

    home_path = Path(ssot["user_home"])
    # Target the user's local configuration directory
    config_base = home_path / ".config/steamos_diy"
    backup_root = config_base / "backups"

    try:
        backup_root.mkdir(parents=True, exist_ok=True)
        # Ensure the directory is owned by the user if created by root
        if os.getuid() == 0 and ssot["user"] != "root":
            user_info = pwd.getpwnam(ssot["user"])
            os.chown(backup_root, user_info.pw_uid, user_info.pw_gid)
    except Exception as e:
        msg = f"‚ùå CRITICAL: Permission denied when creating {backup_root}"
        print(f"{msg}: {e}", file=sys.stderr)
        sys.exit(1)

    archive_name = backup_root / f"sdy_backup_{timestamp}.tar.gz"
    recap_file = backup_root / "restore_links.sh"

    # 1. Generate Link Restoration Script
    print("üîó Analyzing symbolic links...")
    with open(recap_file, "w") as f:
        f.write(generate_links_recap())

    # 2. Define Backup Sources
    sources = [
        (ssot.get("next_session"), "system/next_session"),
        ("/etc/default/steamos_diy.conf", "system/steamos_diy.conf"),
        ("/etc/systemd/system/steamos_diy.service", "system/service"),
        ("/usr/local/lib/steamos_diy", "source/steamos_diy"),
        (str(config_base), "user/config_steamos"),
        (str(recap_file), "restore_links.sh"),
    ]

    print(f"üì¶ Creating archive: {archive_name.name}...")

    try:
        with tarfile.open(archive_name, "w:gz") as tar:
            for src_path, arc_name in sources:
                if src_path and os.path.exists(src_path):

                    def tar_filter(tarinfo):
                        """Exclude recursive backups and cache files."""
                        if "backups" in tarinfo.name:
                            return None

                        blacklist = [
                            ".ruff_cache",
                            ".git",
                            "__pycache__",
                            ".pytest_cache",
                            ".cache",
                        ]
                        if any(p in tarinfo.name for p in blacklist):
                            return None

                        return tarinfo

                    tar.add(src_path, arcname=arc_name, filter=tar_filter)
                    print(f"  + Added: {src_path}")

        # Final ownership adjustment for the archive
        if os.getuid() == 0 and ssot["user"] != "root":
            user_info = pwd.getpwnam(ssot["user"])
            os.chown(archive_name, user_info.pw_uid, user_info.pw_gid)

        # Cleanup: Remove temporary script (now inside the archive)
        if recap_file.exists():
            recap_file.unlink()

        print("\n‚úÖ Backup completed successfully!")
        print(f"üìç Destination: {archive_name}")

    except Exception as e:
        print(f"\n‚ùå ERROR during backup process: {e}", file=sys.stderr)
        if archive_name.exists():
            archive_name.unlink()
        sys.exit(1)


if __name__ == "__main__":
    run_backup()
